# DSL 设计的一点建议和思考

## 1.使用非流程式的定义
### 1.1 什么叫做流程式的定义呢？  
就是按照先后顺序进行定义。虽然这样符合正常的思考顺序,但是并没有非流程的定义在表达上的灵活。  
比如一个流程是下面这样的。
```ditaa {cmd=true args=["-E"]}
           +----------------------+    +------------+    +---------------+   +------------+  
 start --> |          A           +-+->|     B      +-+->|       C       +-->|     D      +--> end
           +----------------------+ |  +------------+ |  +---------------+   +------------+
                      ^             |                 |
                      |             |                 |
                      +-------------+-----------------+
```

如果使用流程的定义方式可能像下面这样：

```
@DSLstart
start->A
A->B else A
B->C else A
C->D
D->end
@DSLend
```

### 1.2 什么叫做`非`流程式的定义呢？
而使用非流程式的定义。**实体和关系是分开的**。它可能的形式是下面这样的:

```
# 注意下面的思考过程的伪代码
@DSLstart
entry:A{
    # 注释! 这是实体A
    ...
}
entry:B{
    ...
}
entry:C{
    ...
}
entry:D{
    ...
}
links{
    start with A;
    end with D;
    # 这里使用bool值
    A->B condition(true)
    A->A condition(false)
    # 这里使用信号
    B->C condition(signal_a)
    B->A condition(signal_b)

    C->D
}

signals{
    signal_a: ...
    signal_b: ...
}

@DSLend
```

### 1.3 为什么要分开定义？
或许我们发现不是流程定义的方式，似乎不那么直观了。但是我们换来了一些好处：
- 可以方便的定义复杂的关系！
- 可以方便的修复和添加原来的关系！
- 实体和关系分开定义更利于代码的执行！

#### 1.3.1 关于`可以方便的定义复杂的关系！`

如果我们想定义一个的复杂的关系只使用箭头和符号或许并不太足够。在一些复杂的情况下使用箭头似乎也不是太好标识。（也就是说我上面写的方式也应该做出一定的修改）  
所以我们应该引入到**函数**的概念。**理论上每个符号其实应该是标识关系跳转函数的某种语法糖而已。**  
比如我现在有个函数定义是下面这样的：
```
BoolToEntry(entry input,bool state,entry output1,entry output2) -> entry;
```
> 为了方便我这里要先说明一下这里伪代码的格式.  
> `entry`表示实体。你可以理解成一种数据类型。上面的BoolToEntry是这个函数的名称。后面是形参表。而->后的entry标识它的返回值还是一个entry实体类型。那么这个方法的意思是什么呢？实体input在状态state下链接到实体output1不然跳到实体output2上。

于是乎我们看到下面的定义
```
 # 这里使用bool值
    A->B condition(true)
    A->A condition(false)
```

可以改成 
```
BoolToEntry(A,true,B,A)
```

这里比较特殊有两个地方可以优化成别的快捷方法。  
首先。这里有个比较特殊的地方他是成功才到下一个地方的。我们可以定义下面的一个函数
```
TrueToEntry(entry input,entry output1,entry output2) -> entry
{
    retrun BoolToEntry(input,true,output1,output2)
}
```

好了我们现在可以简化这个函数为一个符号了！
比如是用`[]->([],[])`来表示。上面的过程可以写为：
```
A->(B,A)
```

其次我们发现在失败时这个实体指向了它自己那么我们是不是可以定义一个失败了指向自己的函数
```
FalseToSelf(entry input,entry output1)->entry
{
    return TrueToEntry(input,output1,input);
}
```

好了我们可以把这个流程优化为一个新的符号。比如`[]->([],)`
于是这个流程又简化为
```
A->(B,)
```

关于`瀑布流程`,`串行流程`,`并行分支流程`,`有限分支流程`,`并行重复流程`（流程中计数）都可以用函数表示。关于这部分可以用先有的js或者其他语言的解析器进行逻辑处理。  
而且关于函数的跟多深入操作将在后面展开讨论。

#### 1.3.2 为什么可以方便的修复和添加原来的关系？

简单的来说，我们有的时候不是那么确认整体之间的关系。而比较容易清楚的了解两个到三个实体之间的关系。所以在使用DSL写作时，是很有可能修改关系的。如果要在大的流程中修改无疑是很繁琐的。或者说远远没有在适当的地方添加一行和删除一行来的优雅。

#### 1.3.3 何为`实体和关系分开定义更利于代码的执行`？

流程图，或者叫工作流。在本质上其实是一种有向图。而实体关系的方式和图的定义是一致的。比较有利于在在代码上构建图。而且在可视化时也是需要这样图的数据结构。所以从代码的角度，分开定义是一件自然想到的事情。


## 2.支持继承和复用
### 2.1 为什么要继承？
### 2.2 如果才能好的复用？


## 3.建立基础函数库 支持 用户自定义扩展
### 3.1 建立基础函数库的必要性？
### 3.2 用户自定义扩展让用户扩展什么


## 4. 语法核心的`实体`和`关系`

## 5. 使用统一的信号（signal）

## 6. 所见即所得的重要性

## 7. 一种代码内跳转的设想

## 8. 